{
  "SCPO Node.js API": {
    "prefix": "scpo-node-api",
    "body": [
      "const express = require('express');",
      "const { body, validationResult } = require('express-validator');",
      "const ${1:ResourceName}Service = require('../services/${1/(.*)/${1:/downcase}/}Service');",
      "",
      "/**",
      " * ${1:ResourceName} Router - Generated with SCPO",
      " * Task: ${2:API endpoints para recurso}",
      " * Constraints: Express.js, Validation, Error handling",
      " */",
      "",
      "const router = express.Router();",
      "",
      "// Validation middleware",
      "const validate${1:ResourceName} = [",
      "  body('${3:title}')",
      "    .notEmpty()",
      "    .withMessage('${3/(.*)/${1:/capitalize}/} is required')",
      "    .isLength({ min: 3, max: 255 })",
      "    .withMessage('${3/(.*)/${1:/capitalize}/} must be between 3 and 255 characters'),",
      "  body('${4:description}')",
      "    .optional()",
      "    .isLength({ max: 1000 })",
      "    .withMessage('${4/(.*)/${1:/capitalize}/} must be less than 1000 characters'),",
      "  body('${5:status}')",
      "    .optional()",
      "    .isIn(['${6:active}', '${7:inactive}', '${8:draft}'])",
      "    .withMessage('Invalid status value')",
      "];",
      "",
      "/**",
      " * GET /${9:${1:resource}s} - List all ${1:resource}s",
      " */",
      "router.get('/', async (req, res) => {",
      "  try {",
      "    const { page = 1, limit = 20, search, ${5:status} } = req.query;",
      "    ",
      "    const ${10:options} = {",
      "      page: parseInt(page),",
      "      limit: parseInt(limit),",
      "      search,",
      "      ${5:status}",
      "    };",
      "    ",
      "    const ${11:result} = await ${1:ResourceName}Service.findAll(${10:options});",
      "    ",
      "    res.json({",
      "      success: true,",
      "      data: ${11:result}.data,",
      "      pagination: ${11:result}.pagination",
      "    });",
      "    ",
      "  } catch (error) {",
      "    console.error('Error fetching ${1:resource}s:', error);",
      "    res.status(500).json({",
      "      success: false,",
      "      message: 'Internal server error',",
      "      error: process.env.NODE_ENV === 'development' ? error.message : undefined",
      "    });",
      "  }",
      "});",
      "",
      "/**",
      " * GET /${9:${1:resource}s}/:id - Get single ${1:resource}",
      " */",
      "router.get('/:id', async (req, res) => {",
      "  try {",
      "    const { id } = req.params;",
      "    ",
      "    const ${1:resource} = await ${1:ResourceName}Service.findById(id);",
      "    ",
      "    if (!${1:resource}) {",
      "      return res.status(404).json({",
      "        success: false,",
      "        message: '${1/(.*)/${1:/capitalize}/} not found'",
      "      });",
      "    }",
      "    ",
      "    res.json({",
      "      success: true,",
      "      data: ${1:resource}",
      "    });",
      "    ",
      "  } catch (error) {",
      "    console.error('Error fetching ${1:resource}:', error);",
      "    res.status(500).json({",
      "      success: false,",
      "      message: 'Internal server error'",
      "    });",
      "  }",
      "});",
      "",
      "/**",
      " * POST /${9:${1:resource}s} - Create new ${1:resource}",
      " */",
      "router.post('/', validate${1:ResourceName}, async (req, res) => {",
      "  try {",
      "    const errors = validationResult(req);",
      "    if (!errors.isEmpty()) {",
      "      return res.status(400).json({",
      "        success: false,",
      "        message: 'Validation error',",
      "        errors: errors.array()",
      "      });",
      "    }",
      "    ",
      "    const ${12:${1:resource}Data} = req.body;",
      "    const ${13:new${1:ResourceName}} = await ${1:ResourceName}Service.create(${12:${1:resource}Data});",
      "    ",
      "    res.status(201).json({",
      "      success: true,",
      "      data: ${13:new${1:ResourceName}},",
      "      message: '${1/(.*)/${1:/capitalize}/} created successfully'",
      "    });",
      "    ",
      "  } catch (error) {",
      "    console.error('Error creating ${1:resource}:', error);",
      "    ",
      "    if (error.name === 'ValidationError') {",
      "      return res.status(400).json({",
      "        success: false,",
      "        message: error.message",
      "      });",
      "    }",
      "    ",
      "    res.status(500).json({",
      "      success: false,",
      "      message: 'Internal server error'",
      "    });",
      "  }",
      "});",
      "",
      "/**",
      " * PUT /${9:${1:resource}s}/:id - Update ${1:resource}",
      " */",
      "router.put('/:id', validate${1:ResourceName}, async (req, res) => {",
      "  try {",
      "    const errors = validationResult(req);",
      "    if (!errors.isEmpty()) {",
      "      return res.status(400).json({",
      "        success: false,",
      "        message: 'Validation error',",
      "        errors: errors.array()",
      "      });",
      "    }",
      "    ",
      "    const { id } = req.params;",
      "    const ${14:updateData} = req.body;",
      "    ",
      "    const ${15:updated${1:ResourceName}} = await ${1:ResourceName}Service.update(id, ${14:updateData});",
      "    ",
      "    if (!${15:updated${1:ResourceName}}) {",
      "      return res.status(404).json({",
      "        success: false,",
      "        message: '${1/(.*)/${1:/capitalize}/} not found'",
      "      });",
      "    }",
      "    ",
      "    res.json({",
      "      success: true,",
      "      data: ${15:updated${1:ResourceName}},",
      "      message: '${1/(.*)/${1:/capitalize}/} updated successfully'",
      "    });",
      "    ",
      "  } catch (error) {",
      "    console.error('Error updating ${1:resource}:', error);",
      "    res.status(500).json({",
      "      success: false,",
      "      message: 'Internal server error'",
      "    });",
      "  }",
      "});",
      "",
      "/**",
      " * DELETE /${9:${1:resource}s}/:id - Delete ${1:resource}",
      " */",
      "router.delete('/:id', async (req, res) => {",
      "  try {",
      "    const { id } = req.params;",
      "    ",
      "    const ${16:deleted} = await ${1:ResourceName}Service.delete(id);",
      "    ",
      "    if (!${16:deleted}) {",
      "      return res.status(404).json({",
      "        success: false,",
      "        message: '${1/(.*)/${1:/capitalize}/} not found'",
      "      });",
      "    }",
      "    ",
      "    res.status(204).send();",
      "    ",
      "  } catch (error) {",
      "    console.error('Error deleting ${1:resource}:', error);",
      "    res.status(500).json({",
      "      success: false,",
      "      message: 'Internal server error'",
      "    });",
      "  }",
      "});",
      "",
      "module.exports = router;",
      "${0}"
    ],
    "description": "Node.js Express API com validação completa"
  },

  "SCPO Node Service": {
    "prefix": "scpo-node-service", 
    "body": [
      "const ${1:Model} = require('../models/${1/(.*)/${1:/downcase}/}');",
      "",
      "/**",
      " * ${1:Model}Service - Generated with SCPO",
      " * Task: ${2:Business logic para gerenciar recursos}",
      " * Constraints: Repository pattern, Error handling, Validation",
      " */",
      "",
      "class ${1:Model}Service {",
      "  /**",
      "   * Find all ${1:model}s with pagination and filtering",
      "   */",
      "  static async findAll(options = {}) {",
      "    const {",
      "      page = 1,",
      "      limit = 20,",
      "      search,",
      "      ${3:status},",
      "      ${4:sortBy} = 'createdAt',",
      "      ${5:sortOrder} = 'DESC'",
      "    } = options;",
      "",
      "    const offset = (page - 1) * limit;",
      "    ",
      "    // Build where clause",
      "    const where = {};",
      "    ",
      "    if (search) {",
      "      where[Op.or] = [",
      "        { ${6:title}: { [Op.iLike]: `%${search}%` } },",
      "        { ${7:description}: { [Op.iLike]: `%${search}%` } }",
      "      ];",
      "    }",
      "    ",
      "    if (${3:status}) {",
      "      where.${3:status} = ${3:status};",
      "    }",
      "",
      "    const { count, rows } = await ${1:Model}.findAndCountAll({",
      "      where,",
      "      limit: parseInt(limit),",
      "      offset: parseInt(offset),",
      "      order: [[${4:sortBy}, ${5:sortOrder}]],",
      "      include: [${8:// Add relations here}]",
      "    });",
      "",
      "    return {",
      "      data: rows,",
      "      pagination: {",
      "        page: parseInt(page),",
      "        limit: parseInt(limit),",
      "        total: count,",
      "        totalPages: Math.ceil(count / limit)",
      "      }",
      "    };",
      "  }",
      "",
      "  /**",
      "   * Find ${1:model} by ID",
      "   */",
      "  static async findById(id) {",
      "    const ${1:model} = await ${1:Model}.findByPk(id, {",
      "      include: [${8:// Add relations here}]",
      "    });",
      "    ",
      "    return ${1:model};",
      "  }",
      "",
      "  /**",
      "   * Create new ${1:model}",
      "   */",
      "  static async create(data) {",
      "    // Validation",
      "    await this._validateCreate(data);",
      "    ",
      "    const ${1:model} = await ${1:Model}.create(data);",
      "    ",
      "    // Reload with relations",
      "    return await this.findById(${1:model}.id);",
      "  }",
      "",
      "  /**",
      "   * Update ${1:model}",
      "   */",
      "  static async update(id, data) {",
      "    const ${1:model} = await this.findById(id);",
      "    ",
      "    if (!${1:model}) {",
      "      return null;",
      "    }",
      "    ",
      "    // Validation",
      "    await this._validateUpdate(${1:model}, data);",
      "    ",
      "    await ${1:model}.update(data);",
      "    ",
      "    // Return updated ${1:model}",
      "    return await this.findById(id);",
      "  }",
      "",
      "  /**",
      "   * Delete ${1:model}",
      "   */",
      "  static async delete(id) {",
      "    const ${1:model} = await this.findById(id);",
      "    ",
      "    if (!${1:model}) {",
      "      return false;",
      "    }",
      "    ",
      "    await ${1:model}.destroy();",
      "    return true;",
      "  }",
      "",
      "  /**",
      "   * Validate data before creating",
      "   */",
      "  static async _validateCreate(data) {",
      "    // Check for duplicates",
      "    if (data.${6:title}) {",
      "      const existing = await ${1:Model}.findOne({",
      "        where: { ${6:title}: data.${6:title} }",
      "      });",
      "      ",
      "      if (existing) {",
      "        throw new Error(`${1:Model} with ${6:title} '${data.${6:title}}' already exists`);",
      "      }",
      "    }",
      "    ",
      "    ${9:// Add custom validation logic here}",
      "  }",
      "",
      "  /**",
      "   * Validate data before updating",
      "   */",
      "  static async _validateUpdate(${1:model}, data) {",
      "    // Check for duplicates if ${6:title} is being updated",
      "    if (data.${6:title} && data.${6:title} !== ${1:model}.${6:title}) {",
      "      const existing = await ${1:Model}.findOne({",
      "        where: { ",
      "          ${6:title}: data.${6:title},",
      "          id: { [Op.ne]: ${1:model}.id }",
      "        }",
      "      });",
      "      ",
      "      if (existing) {",
      "        throw new Error(`${1:Model} with ${6:title} '${data.${6:title}}' already exists`);",
      "      }",
      "    }",
      "    ",
      "    ${10:// Add custom validation logic here}",
      "  }",
      "",
      "  /**",
      "   * Get ${1:model}s statistics",
      "   */",
      "  static async getStats() {",
      "    const [total, active, inactive] = await Promise.all([",
      "      ${1:Model}.count(),",
      "      ${1:Model}.count({ where: { ${3:status}: 'active' } }),",
      "      ${1:Model}.count({ where: { ${3:status}: 'inactive' } })",
      "    ]);",
      "    ",
      "    return { total, active, inactive };",
      "  }",
      "}",
      "",
      "module.exports = ${1:Model}Service;",
      "${0}"
    ],
    "description": "Service Node.js com business logic completo"
  },

  "SCPO Node Test": {
    "prefix": "scpo-node-test",
    "body": [
      "const request = require('supertest');",
      "const { expect } = require('chai');",
      "const app = require('../../../app');",
      "const ${1:Model} = require('../../models/${1/(.*)/${1:/downcase}/}');",
      "",
      "/**",
      " * ${1:Model} API Tests - Generated with SCPO",
      " * Task: ${2:Testar endpoints da API}",
      " * Constraints: Mocha, Chai, Supertest, Database cleanup",
      " */",
      "",
      "describe('${1:Model} API', () => {",
      "  let ${3:test${1:Model}};",
      "  let ${4:authToken};",
      "",
      "  before(async () => {",
      "    // Setup test data",
      "    ${3:test${1:Model}} = await ${1:Model}.create({",
      "      ${5:title}: 'Test ${1:Model}',",
      "      ${6:description}: 'Test description',",
      "      ${7:status}: 'active'",
      "    });",
      "    ",
      "    // Get auth token (if needed)",
      "    ${4:authToken} = 'Bearer test-token';",
      "  });",
      "",
      "  after(async () => {",
      "    // Cleanup test data",
      "    await ${1:Model}.destroy({",
      "      where: { ${5:title}: { [Op.like]: '%Test%' } }",
      "    });",
      "  });",
      "",
      "  describe('GET /${8:${1:model}s}', () => {",
      "    it('should return list of ${1:model}s', async () => {",
      "      const response = await request(app)",
      "        .get('/${8:${1:model}s}')",
      "        .set('Authorization', ${4:authToken})",
      "        .expect(200);",
      "",
      "      expect(response.body.success).to.be.true;",
      "      expect(response.body.data).to.be.an('array');",
      "      expect(response.body.pagination).to.be.an('object');",
      "    });",
      "",
      "    it('should filter ${1:model}s by search', async () => {",
      "      const response = await request(app)",
      "        .get('/${8:${1:model}s}?search=Test')",
      "        .set('Authorization', ${4:authToken})",
      "        .expect(200);",
      "",
      "      expect(response.body.success).to.be.true;",
      "      expect(response.body.data).to.be.an('array');",
      "      ",
      "      const ${9:foundItem} = response.body.data.find(item => item.id === ${3:test${1:Model}}.id);",
      "      expect(${9:foundItem}).to.exist;",
      "    });",
      "",
      "    it('should paginate results correctly', async () => {",
      "      const response = await request(app)",
      "        .get('/${8:${1:model}s}?page=1&limit=5')",
      "        .set('Authorization', ${4:authToken})",
      "        .expect(200);",
      "",
      "      expect(response.body.pagination.page).to.equal(1);",
      "      expect(response.body.pagination.limit).to.equal(5);",
      "    });",
      "  });",
      "",
      "  describe('GET /${8:${1:model}s}/:id', () => {",
      "    it('should return single ${1:model}', async () => {",
      "      const response = await request(app)",
      "        .get(`/${8:${1:model}s}/${${3:test${1:Model}}.id}`)",
      "        .set('Authorization', ${4:authToken})",
      "        .expect(200);",
      "",
      "      expect(response.body.success).to.be.true;",
      "      expect(response.body.data.id).to.equal(${3:test${1:Model}}.id);",
      "      expect(response.body.data.${5:title}).to.equal('Test ${1:Model}');",
      "    });",
      "",
      "    it('should return 404 for non-existent ${1:model}', async () => {",
      "      const response = await request(app)",
      "        .get('/${8:${1:model}s}/99999')",
      "        .set('Authorization', ${4:authToken})",
      "        .expect(404);",
      "",
      "      expect(response.body.success).to.be.false;",
      "      expect(response.body.message).to.contain('not found');",
      "    });",
      "  });",
      "",
      "  describe('POST /${8:${1:model}s}', () => {",
      "    it('should create new ${1:model}', async () => {",
      "      const ${10:newData} = {",
      "        ${5:title}: 'New Test ${1:Model}',",
      "        ${6:description}: 'New test description',",
      "        ${7:status}: 'active'",
      "      };",
      "",
      "      const response = await request(app)",
      "        .post('/${8:${1:model}s}')",
      "        .set('Authorization', ${4:authToken})",
      "        .send(${10:newData})",
      "        .expect(201);",
      "",
      "      expect(response.body.success).to.be.true;",
      "      expect(response.body.data.${5:title}).to.equal(${10:newData}.${5:title});",
      "      expect(response.body.data.id).to.exist;",
      "    });",
      "",
      "    it('should validate required fields', async () => {",
      "      const ${11:invalidData} = {",
      "        ${6:description}: 'Missing title'",
      "      };",
      "",
      "      const response = await request(app)",
      "        .post('/${8:${1:model}s}')",
      "        .set('Authorization', ${4:authToken})",
      "        .send(${11:invalidData})",
      "        .expect(400);",
      "",
      "      expect(response.body.success).to.be.false;",
      "      expect(response.body.errors).to.be.an('array');",
      "    });",
      "",
      "    it('should prevent duplicate ${5:title}s', async () => {",
      "      const ${12:duplicateData} = {",
      "        ${5:title}: '${3:test${1:Model}}.${5:title}',",
      "        ${6:description}: 'Duplicate description'",
      "      };",
      "",
      "      const response = await request(app)",
      "        .post('/${8:${1:model}s}')",
      "        .set('Authorization', ${4:authToken})",
      "        .send(${12:duplicateData})",
      "        .expect(400);",
      "",
      "      expect(response.body.success).to.be.false;",
      "      expect(response.body.message).to.contain('already exists');",
      "    });",
      "  });",
      "",
      "  describe('PUT /${8:${1:model}s}/:id', () => {",
      "    it('should update existing ${1:model}', async () => {",
      "      const ${13:updateData} = {",
      "        ${5:title}: 'Updated Test ${1:Model}',",
      "        ${6:description}: 'Updated description'",
      "      };",
      "",
      "      const response = await request(app)",
      "        .put(`/${8:${1:model}s}/${${3:test${1:Model}}.id}`)",
      "        .set('Authorization', ${4:authToken})",
      "        .send(${13:updateData})",
      "        .expect(200);",
      "",
      "      expect(response.body.success).to.be.true;",
      "      expect(response.body.data.${5:title}).to.equal(${13:updateData}.${5:title});",
      "    });",
      "",
      "    it('should return 404 for non-existent ${1:model}', async () => {",
      "      const response = await request(app)",
      "        .put('/${8:${1:model}s}/99999')",
      "        .set('Authorization', ${4:authToken})",
      "        .send({ ${5:title}: 'Updated' })",
      "        .expect(404);",
      "",
      "      expect(response.body.success).to.be.false;",
      "    });",
      "  });",
      "",
      "  describe('DELETE /${8:${1:model}s}/:id', () => {",
      "    let ${14:deleteTest${1:Model}};",
      "",
      "    beforeEach(async () => {",
      "      ${14:deleteTest${1:Model}} = await ${1:Model}.create({",
      "        ${5:title}: 'To Delete ${1:Model}',",
      "        ${6:description}: 'Will be deleted'",
      "      });",
      "    });",
      "",
      "    it('should delete existing ${1:model}', async () => {",
      "      const response = await request(app)",
      "        .delete(`/${8:${1:model}s}/${${14:deleteTest${1:Model}}.id}`)",
      "        .set('Authorization', ${4:authToken})",
      "        .expect(204);",
      "",
      "      // Verify deletion",
      "      const ${15:deletedModel} = await ${1:Model}.findByPk(${14:deleteTest${1:Model}}.id);",
      "      expect(${15:deletedModel}).to.be.null;",
      "    });",
      "",
      "    it('should return 404 for non-existent ${1:model}', async () => {",
      "      const response = await request(app)",
      "        .delete('/${8:${1:model}s}/99999')",
      "        .set('Authorization', ${4:authToken})",
      "        .expect(404);",
      "",
      "      expect(response.body.success).to.be.false;",
      "    });",
      "  });",
      "",
      "${0}",
      "});"
    ],
    "description": "Testes Node.js completos com Mocha e Chai"
  }
}